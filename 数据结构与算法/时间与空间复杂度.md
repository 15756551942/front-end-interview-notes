## 什么是复杂度分析
1. 数据结构和算法解决的是如何让计算机更少时间，更省空间的解决问题
2. 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能
3. 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度
4. 复杂度描述的是算法执行时间或占用空间与数据规模的增长关系
## 为什么要进行复杂度分析
1. 和性能测试相比，复杂度分析有不依赖执行环境，成本低，效率高，易操作，指导性强的特点
2. 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本
## 如何进行复杂度分析
1. 大O(时间复杂度)表示法
算法的执行时间与代码的执行次数成正比，用T(n)=O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行的总次数，n往往表示数据的规模
2. 时间复杂度
* 大O时间复杂度表示法实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫渐进时间复杂度
* 常量，低阶，系数对增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项
3. 时间复杂度分析
* 只关注循环执行次数最多的一段代码，单段代码看高频,
```
T(n)=O(n)

function cal(n) { 
   let sum = 0;
   let i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```
* 加法法则：总复杂度等于量级最大的那段代码的复杂度
```
T(n)=O(n^2)

function cal(n) {
   let sum_1 = 0;
   let p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   let sum_2 = 0;
   let q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   let sum_3 = 0;
   let i = 1;
   let j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```
* 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积,嵌套代码求乘积：比如递归、多重循环等
```
T(n) = T1(n) * T2(n) = O(n*n) = O(n^2) 。

function cal(n) {
   let ret = 0; 
   let i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i); // 重点为  f(i)
   } 
 } 
 
function f(n) {
  let sum = 0;
  let i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```
* 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加
```
T(n) = O(m+n)

function cal(m, n) {
  let sum_1 = 0;
  let i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  let sum_2 = 0;
  let j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```
* 多个规模求乘法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘
```
T(n) = O(m*n)

function cal(m, n) {
  let sum_3 = 0;
   let i = 1;
   let j = 1;
   for (; i <= m; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
}
```